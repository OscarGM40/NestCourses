				SECCION 07 MONGODB POKEDEX

Vamos a empezar a grabar y leer de DB,usaremos un contenedor de Docker.Esta sección enteramente se enfoca en la grabación a base de datos, pero puntualmente:

1- Validaciones
2- CRUD contra base de datos
3- Docker y Docker Compose
4- Conectar contenedor con filesystem (para mantener la data de la base de datos)
5- Schemas
6- Modelos
7- DTOs y sus extensiones
8- Respaldar a Github

			VIDEO 68 INICIO PROYECTO POKEDEX

Creo un nuevo proyecto 'nest new pokedex'.En esta seccion veré como crear un registro de logs de errores,crearemos un custom pipe y una conexión a base de datos.Más adelante haremos lo mismo con PostgreSQL.
NOTA: fijate que puede que tenga que estar borrando todo lo relacionado a prettier

			VIDEO 69 SERVIR CONTENIDO ESTÁTICO

Es muy común ofrecer contenido http al acceder a las urls de mi app(normalmente se sirve una aplicación web,o una pagina web).

Nosotros podemos servir contenido estático con Nest,aunque tenemos que añadir una dependencia y crear la carpeta 'public' en la raiz del proyecto:
>yarn add @nestjs/serve-static

Adicionalmente hay que configurar la app,en el app.module(el modulo más arriba),diciendole donde está ese directorio publico:

* En el app.module.ts le paso el rootPath hasta public:

import { Module } from '@nestjs/common';
import { ServeStaticModule } from '@nestjs/serve-static';
import { join } from 'path';

@Module({
  imports: [
    ServeStaticModule.forRoot({
      rootPath: join(__dirname,'..','public')
    })
  ],
})
export class AppModule {}

Fijate que sólo con esto ya puedo embeber aqui una aplicación de Angular,React,Vue,etc y servirla.

			VIDEO 70 GLOBAL PREFIX

Es muy comun que toda mi app tenga el prefijo /api o /api/v1.Empecemos creando el resource pokemon:
>nest g res pokemon --no-spec

Si ahora voy a Postman puedo ir a /pokemon etc,pero de nuevo es muy comun que sea /api/pokemon.Realmente sería simplemente agregar esto al decorador @Controller:

@Controller('api/pokemon')

Pero podemos configurar globalmente esto,para no repetirlo en cada controlador,basta usar el método app.setGlobalPrefix(string):


async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.setGlobalPrefix('api');
  await app.listen(3000);
}

Y faltaria agregar el versionamiento de la api:
  app.enableVersioning({
    type: VersioningType.URI,
    defaultVersion: '1',
  });

Ahora si,tendré que apuntar a /api/v1/ primero.

				VIDEO 71 DOCKER - DOCKER-COMPOSE MONGO-IMAGE

Copiar un  docker compose con la imagen mongo 5.0.0(importante que ya la tengo).Fijate que necesitó de un param en la MongoURI.

				VIDEO 72 CREAR README

Fijate que importante es crear el Readme.Vamos a dejar el icono y crear una lista ordenada con (1. 2. 3. ) y de bullets con *:

# Ejecutar en desarrollo

1. Clonar el repositorio
2. Ejecutar
```
yarn install
```
3. Se requiere tener Nest CLI instalado
```
npm i -g @nestjs/cli
```
4. Levantar la base de datos(la MONGOURI necesita ?authSource=admin)
```
docker-compose up -d
```

## Stack usado
* MongoDB
* Nest
* ODM Mongoose

Fijate que es importante recalcar el stack usado.

		VIDEO 73 CONECTORES NATIVOS DE NEST

Nest se puede conectar a casi cualquier base de datos,siempre y cuando haya algun adaptador/libreria que lo permita.Usaremos mongoose,pero con un adaptador extra para nest.Este paquete wrapper que se pone encima de mongoose añade funcionalidad extra como mejor manejo de errores,poder usar inyección de dependencias,entities,etc, asi que es totalmente necesario instalar ambos:
>npm install @nestjs/mongoose mongoose

Posteriormente usaremos TypeORM para Postgre.Perfecto.

NOTA: hay que ir al main.ts y traerse el MongooseModule y pasarle una MongoURI.

En el main.ts
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [MongooseModule.forRoot('mongodb://localhost/nest')],

TIP:si la base de datos no esta UP ni siquiera funcionarán los controladores.

				VIDEO 74 CREAR ESQUEMAS Y MODELOS

Cuando estoy trabajando con MongoDB,el gestor me va a proporcionar un id único a nivel mundial(uu).Bien,para enlazar la entidad usaré el decorador @Schema,de forma similar a @Entity en Spring:

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema()
export class Pokemon extends Document {
  @Prop({
    unique: true,
    index: true, //queremos un index para optimizar busquedas sobre el name
  })
  name: string;
  @Prop({
    unique: true,
    index: true,
  })
  no: number;
}

export const PokemonSchema = SchemaFactory.createForClass(Pokemon);

Fijate que tengo que crear el Schema desde la Factory y que cada columna le estoy creando un indice,ya que queremos buscar por name o por no.Además,son únicas.

IMPORTANTE: aun falta otro paso importante,y es definir los modelos.Esta vez se hace en el modulo correspondiente(en este caso en pokemon.module):

@Module({
  controllers: [PokemonController],
  providers: [PokemonService],
  imports: [
    MongooseModule.forFeature([{
      name:Pokemon.name, // la entidad
      schema: PokemonSchema
    }])
  ]
})
export class PokemonModule {}

Fijate que es forFeature y que necesita el Schema y el name.Bastante sencillo.
Esto ya deberia crear una colección,aunque puede que necesite insertar un documento para verla.

			VIDEO 75 POST - RECIBIR Y VALIDAR LA DATA 

Fijate que para las validaciones lo primero será instalar las librerias class-transformer y class-validator:
yarn add class-transformer class-validator


export class CreatePokemonDto {
  @IsInt()
  @IsPositive()
  @Min(1, { message: 'number must be minimum 1' })
  no: number;

  @IsString()
  @MinLength(1, { message: 'string must have at least 1 ch' })
  name: string;
}

			VIDEO 76 CREAR POKEMON EN BASE DE DATOS

Para poder interactuar con el Modelo vamos a tener que inyectar una instancia de tipo Model<Entity>.Realmente ya tenemos todo echo:

 constructor(
    @InjectModel(Pokemon.name)
    private readonly pokemonModel:Model<Pokemon>
    ){}
Fijate que Pokemon es la Entity y que el decorador recibe el name como argumento.Este decorador @InjectModel lo hizo la gente de Nest para que pueda inyectar modelos en un Service(u otra clase).

Ahora si,ya podemos grabar en DB.Realmente lo único que tengo que tener en cuenta es que es una acción asíncrona y tengo que etiquetar el método como async,que no lo estaba(ojo que todos vienen sin async):

  async create(createPokemonDto: CreatePokemonDto) {
    createPokemonDto.name = createPokemonDto.name.toLowerCase();
    
    const pokemon = await this.pokemonModel.create(createPokemonDto);

    return pokemon;
  }

Ahora,si,ya puedo guardar en la dB mi primer documento.Fijate que si vuelvo a intentar guardar el mismo me dará un 500 por que el name es unique.Tenemos que gestionar mejor estos errores.

			VIDEO 77 RESPONDER A UN ERROR ESPECIFICO

Fijate que mongoose me esta dando un Error 11000 Duplicate Key.Si lo imprimo veré esto:
{
  index: 0,
  code: 11000,
  keyPattern: { name: 1 },
  keyValue: { name: 'bulbasaur' },
  [Symbol(errorLabels)]: Set(0) {}
}
Puedo acceder al keyValue para evitar tener que hacer una consulta a la DB.
  
async create(createPokemonDto: CreatePokemonDto) {
    createPokemonDto.name = createPokemonDto.name.toLowerCase();

    try {
      const pokemon = await this.pokemonModel.create(createPokemonDto);
      return pokemon;
    } catch (error) {
      if(error.code === 11000){
        throw new BadRequestException(`Pokemon already exists on DB ${JSON.stringify(error.keyValue)}`)
      }
      console.log(error);
      throw new InternalServerErrorException(`Can't create Pokemon - Check server logs`)
    }
  }

Fijate que debo aprovecharme de estar en la exception Zone.Por último,puedo mandar cualquier StatusCode,tanto poniendo el numero en bruto como usando constantes:

  @Post()
  @HttpCode(200) <- también puedo usar HttpStatus.OK
  create(@Body() createPokemonDto: CreatePokemonDto) {
    return this.pokemonService.create(createPokemonDto);
  }

Es buena idea usar el diccionario de constantes.

		VIDEO 	78 FIND ONE BY ID - BUSCAR POR MONGO ID,NAME O NO

La Api Pokedex ya tiene echos los endpoints para buscar por MongoId,o cualquier campo.Tendremos que ver de que tipo es el param pues:

  async findOne(param: string) {
    let pokemon: Pokemon;
    //si el param  es un no
    if (!isNaN(+param)) {
      // ojo que moongose va a convertir param a number,no hace falta hacerlo
      pokemon = await this.pokemonModel.findOne({ no: param });
    }
    //si el param  es un mongoId
    if (!pokemon && isValidObjectId(param)) {
      pokemon = await this.pokemonModel.findById(param);
    }
    //si el param  es un string
  if (!pokemon) {
      pokemon = await this.pokemonModel.findOne({ name: param });
    } 
	// si no encontramos nada ya si lanzamos un 404
  if(!pokemon){
      throw new NotFoundException(`Pokemon with id,name or no ${param} not found`)
    }
    return pokemon;
  }
Fijate que NotFoundException tira un 404,no confundir una BadRequest que es un 400 con un 404 que es NoContent.

Y observa como hemos usado la función de mongoose isValidObjectId.Genial

				VIDEO 79 ACTUALIZAR POKEMON EN BD

Fijate la importancia de ya tener bien hecho el getOne,asinto:

  async update(term: string, updatePokemonDto: UpdatePokemonDto) {
    // fijate la importancia de llamar en el update al getOne,esto es un estandar y una buena practica
    const pokemon = await this.findOne(term);
    // si llegamos aqui es que he encontrado un pokemon
    if (updatePokemonDto.name) {
      updatePokemonDto.name = updatePokemonDto.name.toLowerCase();
    }
    try {
      await this.pokemonModel.findOneAndUpdate(
        { _id: pokemon._id },
        updatePokemonDto,
      );
      return { ...pokemon.toJSON(), ...updatePokemonDto };
    } catch (error) {
      this.handleExceptions(error);
    }
  }

			VIDEO 81 ELIMINAR UN POKEMON - CUSTOM PIPE 

Realmente queremos que el param sea un MongoId y borrar solo por Id.Crearemos un custom pipe para ello.Este pipe deberia vivir en un lugar global,ya que vale comprobar un mongoId vale para toda la app.
Fijate que Nest ya recomienda crear una carpeta commons para cosas como esta,asi que primero creo el modulo y despues el pipe:

>nest g mo common
>nest g pi common/pipes/parseMongoId <- nombre de la clase


Esto creará una clase con el decorador @Injectable que implementa la interfaz PipeTransform.Todo pipe implementa esta interfaz y debe desarrollar el método abstracsto transform(value,metadata)

@Injectable()
export class ParseMongoIdPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}

IMPORTANTE: los pipes transforman la data,no sólo visualmente,realmente transforman la data,esto es muy importante.
Bien,además que siempre hay que retornar el valor,ya sea modificado o no,con todo esto puedo crearme un Pipe para asi reusarlo masivamente.Genial:

@Injectable()
export class ParseMongoIdPipe implements PipeTransform {
  transform(value: string, metadata: ArgumentMetadata) {
    // console.log({value,metadata})
    if(!isValidObjectId(value)){
      throw new BadRequestException(`${value} is not a valid MongoId`)
    }
    return value;
  }
}

			VIDEO 83 VALIDAR Y ELIMINAR EN UNA SOLA OPERACIÓN	

Podemos mirar la cuenta de los documentos que se borran y si es 0 lanzar un 400 ya que estamos en un Service.Genial:

  async remove(id: string) {
    const { deletedCount } = await this.pokemonModel.deleteOne({ _id: id });
    if( deletedCount === 0) {
      throw new BadRequestException(`Pokemon with id ${id} not found`);
    }
    return;
  }

			SECCION 08 SEED-DATA Y PAGINACION		

Esta sección tiene por objetivo aprender:

1- Uso de modelos en diferentes módulos
2- SEED para llenar la base de datos
3- Paginación de resultados
4- DTOs para Query parameters
5- Transformaciones de DTOs

También les mostraré varias formas de hacer inserciones por lote y varias formas de lograrlo.

			VIDEO 89 CREAR MODULO SEED

Creamos un recurso y dejamos solo el GET.Usaremos axios:
Fijate que él tomó una aproximación diferente ya que exportó el MongooseModule en vez de el service:

  exports:[PokemonService,MongooseModule]
})
export class PokemonModule {}
Realmente solo queria que vieramos que podemos exportar el modulo o el servicio.Obviamente es mejor exportar el servicio ya que tiene las validaciones,etc...

NOTA: tenemos un problema si fueran miles de registros ya que no estamos usando paralelismo,pero podemos hacerlo y deberiamos.

		VIDEO 93 INSERTAR VARIOS REGISTROS SIMULTANEAMENTE-EN PARALELO

Una forma sería con Promise.all y anteriormente metiendo el create en cada posición.
   // forma uno
      insertPromisesArray.push(this.pokemonService.create({name,no}))
      await Promise.all(insertPromisesArray)

Sin embargo hay una forma mejor,con insertMany:

    const pokemonToInsert: { name: string; no: number }[] = [];

    data.results.forEach(async ({ name, url }) => {
      const segments = url.split('/');
      const no: number = +segments[segments.length - 2];
      // forma uno
      // insertPromisesArray.push(this.pokemonService.create({name,no}))
      // await Promise.all(insertPromisesArray)

      // forma dos
      pokemonToInsert.push({ name, no });
      // await this.pokemonService.create({ name, no });
    });
    await this.pokemonModel.insertMany(pokemonToInsert)
    return data;
Recuerda que el MongooseModule lo inyecté asi:
@InjectModel(Pokemon.name)
private readonly pokemonModel: Model<Pokemon>

NOTA: normalmente este endpoint estará restringido,etc

				VIDEO 94 CREAR UN CUSTOM PROVIDER

Ya hemos comentado que la clase SeedService tiene la dependencia de axios,y por ello está acoplada a esta libreria.Sería mejor abstraer esta lógica de la clase y poder cambiar axios por fetch mediante el principio de sustitución de Liskov.

Recuerda que un Provider tiene que estar definido en el módulo más cercano y que todo Provider puede ser inyectado(de ahi su nombre,puede ser proveido)

Realmente es muy sencillo crear una abstración de Axios o fetch.Lo primero es crear la abstracción.Usaremos una interface:

export interface HttpAdapter {
  get<T>(url:string):Promise<T>; <- y asi para los 4 verbos
}

Despues creo las implementaciones,recuerda que debo anotarlas con @Injectable.

@Injectable()
export class AxiosAdapter implements HttpAdapter {
  private readonly axios:AxiosInstance = axios;

  async get<T>(url:string):Promise<T> {
    try{
      const {data} = await this.axios.get<T>(url);
      return data;
    } catch(error) {
     throw new Error('This is an error'); <- habria que gestionar mejor el error  	
IMPORTANTE: recuerda que es un Provider y que estoy en otro modulo,tengo que declararlo como Provider y además exportarlo( y además importar este modulo despues en cada otro modulo que quiera usar este provider) para poder inyectarlo en el SeedModule:

@Module({
  providers: [AxiosAdapter],
  exports: [AxiosAdapter]
})
export class CommonModule {}

Y recuerda, tengo que importar este modulo en el SeedModule:

@Module({
  imports:[PokemonModule,CommonModule],
  controllers: [SeedController],
  providers: [SeedService]
})
export class SeedModule {}


Ya sólo queda usarlo,inyectando el axiosAdapter,que será intercambiable(fijate que inyecto la implementación,pero es intercambiable al extender la interfaz por cualquier otra que tmb la implemente).Perfecto.

 constructor(
    @InjectModel(Pokemon.name)
    private readonly pokemonModel: Model<Pokemon>,
    private readonly pokemonService: PokemonService,
    private readonly axiosAdapter: AxiosAdapter,
  ) {}

  async executeSeed() {
    const data = await this.axiosAdapter.get<PokeResponse>(
      'https://pokeapi.co/api/v2/pokemon?limit=650',
    );

				VIDEO 95 PAGINACION DE POKEMONS

 La API oficial de Pokemon permite mandarle dos queryParams para la paginación:
https://pokeapi.co/api/v2/pokemon?offset=20&limit=20

Dado que vamos a pasarlos por los query parameters vamos a necesitar el decorador @Query,que rescata todos los parametros de la query de una request:

  @Get()
  findAll(@Query() queryParameters) {
    console.log(queryParameters);
    return this.pokemonService.findAll();
  }
NOTA: queryParameters es un objeto.Cada propiedad será un query param.Fijate que tenemos que validarlos,si necesitamos un offset y un limit deben ser de tipo number,etc
Asi podremos hacer this.pokemonModel.find().limit(limit).skip(offset);
Vamos a crearnos un dto para este objeto queryParameters con estas validaciones.
Esta clase va a lucir asi con las validaciones:

export class PaginationDto {

  @IsOptional()
  @IsPositive()
  @Min(1)
  limit:number;

  @IsOptional()
  @IsPositive()
  offset:number;
}

Sin embargo,si intento ir a https://localhost:3000/api/v1/pokemon?limit=10 veré que llega como un string y me viene un BadRequest

			VIDEO 96 TRANSFORMING PAGINATION-DTO

En nuestro main.ts puedo hacer una configuración global para que los dtos transformen la data a lo que estan esperando.Esto es un poco más costoso. Para ello basta con usar dos propiedades más,transform y transformOptions:

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, //filtra las propiedades
      forbidNonWhitelisted: true, //lanza 400 si vienen de más
      transform:true, // permitir que los dtos transformen la data
      transformOptions:{
        enableImplicitConversion:true
      }
    }),
  );

Ahora si,con esta configuración ya tengo los argumentos necesarios para pasarlos del controller al service:
  
@Get()
  findAll(@Query() {offset,limit}:PaginationDto) {
    return this.pokemonService.findAll(offset,limit);
  }

Y el service simplemente llama al limit y skip con estos datos:
  async findAll(offset: number = 0, limit: number = 10) {
    return this.pokemonModel.find()
      .limit(limit)
      .skip(offset)
      .sort({no:1})
      .select('-__v');
  }
En la siguiente sección vamos a desplegar todo esto,usando Docker tmb.

		SECCIÓN 9 CONFIGURAR VARIABLE DE ENTORNO Y DESPLIEGUE CON DOCKER

Vamos a desplegar con Heroku.Crearemos un docker-compose con una composición de una imagen de Mongo y otra de Nest,muy interesante.
En esta sección trabajaremos en la configuración de variables de entorno y su validación:
Puntualmente veremos:

1- Dockerizacion
2- Mongo Atlas
3- Env file
4- joi
5- Validation Schemas
6- Configuration Module
7- Recomendaciones para un Readme útil
8- Despliegues
9- Dockerfile

Fijate que aún no hemos creado ningun .env para variables de entorno.

			VIDEO 101 VARIABLES DE ENTORNO

Obviamente nos hemos dejado literales como el puerto o la MongoURI que deberían estar en variables de entorno.
Normalmente van en la raiz del proyecto en un archivo .env.Sin embargo,nest no va a leer el archivo .env sólo por crearlo, a diferencia de Express.

Para que Nest pueda leer el .env hay que instalar el modulo @nestjs/config:
>yarn add @nestjs/config

Y en el app.module hay que importar el modulo:
@Module({
  imports: [ ConfigModule.forRoot() ]

Ojo,que este modulo tiene que estar encima de por ejemplo este,ya que lleva el ConfigModule como dependencia:
   MongooseModule.forRoot(process.env.MONGODB, {
      authSource: 'admin',
    }),

				VIDEO 102 CONFIGURATION LOADER

Adicionalmente al ConfigModule también se recomienda que si voy a hacer uso dentro de un building block(un servicio,un controlador) de una variable de entorno,que lo haga mediante un Servicio.
En Nest es común crear un objeto con las env que quiero,mapeandolas:

En /config/app.config.ts:
export const EnvConfiguration = () => ({
  // variable que me dice el entorno
  environment : process.env.NODE_ENV === 'dev',
  mongodb: process.env.MONGODB,
  port: process.env.PORT || 3001,
  defaultLimit: process.env.DEFAULT_LIMIT || 7,
})

Y para que lo lea se lo paso en el forRoot(load:[object]):
 ConfigModule.forRoot({
      load:[EnvConfiguration] < -fijate que es un array de objetos
  }),

Ahora si,ya podemos usar el Servicio que ofrece el configModule y recomiendan

			VIDEO 103 CONFIGURATION SERVICE

En el momento en que intente inyectar ese servicio veré que tengo que declararlo como Provider en ese modulo:

  constructor(
    @InjectModel(Pokemon.name)
    private readonly pokemonModel: Model<Pokemon>,
    private readonly configService: ConfigService
  ) { }

  imports: [ConfigModule] <- tengo que importar el configModule en el modulo que inyecte el servicio

Ahora si,ya puedo usar su método get<T> de la clase del servicio para acceder a mi config.Fijate que me viene incluso como numero.

    private readonly configService: ConfigService) { 
    console.log(this.configService.get<number>('defaultLimit'))
  }

Y cabe recalcar que en los building blocks tengo que usar el servicio(es obligatorio o solo opcional),pero en el main.ts no estoy en un building block y puedo usar process.env:

En el main.ts:
  await app.listen(process.env.PORT, () => {
    console.clear();
    console.log('listening on port ' + process.env.PORT);
  });

		VIDEO 104 VALIDATION-SCHEMA PARA LAS ENV - JOI LIBRARY

Recuerda que Subject y sus derivados son todas multicasting(Behaviour además necesita un valor inicial y la otra guarda un registro de las emisiones y se las da acualquier nuevo observer que se una)

Siempre que quiera ser más estricto con la validación de un tipo(en este caso es un simple objeto,fijate que no tiene nada que ver con formularios9 puedo instalar joi(npm i joi).Anteriormente era hapi/joi,pero recomiendan pasarse ya a joi

import * as Joi from 'joi';

// debo crearme un Schema de validación
export const JoiValidationSchema = Joi.object({
  MONGODB: Joi.required(),
  PORT:Joi.number().default(3005),
  DEFAULT_LIMIT: Joi.number().default(6)
})

Afortunadamente,le puedo pasar este schema al ConfigModule en la propiedad validationSchema.

@Module({
  imports: [
    ConfigModule.forRoot({
      load:[EnvConfiguration],
      validationSchema:JoiValidationSchema
  }),

Ahora si,esta aplicación va a necesitar la variable MONGODB,por ejemplo,ya que es required,las otras dos como tienen un default()no necesitan ser required().

				VIDEO 105 ARCHIVO ENV-TEMPLATE

Realmente no es buena idea no comunicar como lucen las variables de entorno.FH recomienda crear un .env.template,e incluso se pueden llenar algunas o dar una pequeña descripcion:

MONGODB= la URI
PORT=se espera el 3000
DEFAULT_LIMIT= se espera 10

También se recomienda decir en el README.md que existe el archivo y debe configurarse

DESPLIEGUE A HEROKU: fijate que FH tuvo problemas por estar usando yarn ya que heroku necesita npm.REcuerda tmb que tengo que meter las variables de entorno desde la plataforma,de forma parecida a con Vercel.

				VIDEOS 109-110 DOCKERIZAR LA APP

Vamos a crear un compose,no solo con la imagen de mongo,sino tmb con la de node,asi,al hacer docker-compose up levantaré toda la app(y no solo la db).En resumen haremos un contenedor con toda la app.

Bien,volviendo al video,fijate que vamos a usar las flags -f(file) en el comando docker-compose(ya que voy a tener varios yaml).Muy interesante:
>docker-compose -f docker-compose.prod.yaml (up -d,stop,etc...)
* Simplemente va como primer argumento.

Y no solo eso,sino que como abstraeremos las env variables tamb le puedo pasar unenvFile con --env-file:
>docker-compose -f docker-compose.prod.yaml --env-file .env.prod up -d <- Muy PRO

NOTA: por defecto docker usa el .env por lo que si solo tengo este file no necesito pasarle la flag --env-file

A continuación FH muestra como ejecutar un script de node con un contenedor,de forma simple pero muy acertada:

FROM node:18-alpine3.15

# Set working directory
RUN mkdir -p /var/www/pokedex
WORKDIR /var/www/pokedex

# Copiar el directorio y su contenido
COPY . .
COPY package.json tsconfig.json tsconfig.build.json ./
RUN yarn install --prod
RUN yarn build


# Dar permiso para ejecutar la applicación
RUN adduser --disabled-password pokeuser
RUN chown -R pokeuser:pokeuser /var/www/pokedex
USER pokeuser

# Limpiar el caché
RUN yarn cache clean --force

EXPOSE 3000

CMD [ "yarn","start" ]

Fijate que crea un user para bajar privilegios,y también es agnostico a si se usa TS o JS,etc(claro que el yarn start debe saber lo que hace).
Además,normalmente voy a empaquetar una DB tmb con el script.

	VIDEO 111 DEFINIR LA COMPOSICIÓN DE LA IMAGEN PARA EL SCRIPT REST  + LA DB

Vamos a seguir otra aproximación mejor.Primero instalo sólo las dependencias de mi app con estas lineas:

#PASO UNO:crear una imagen solo con las dependencias y darla un name
FROM node:18-alpine3.15 AS deps

RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile

Despues,en un segundo paso construyo la app con la ayuda de esa primera image(recuerda que FROM crea una imagen):

# PASO DOS: hacer el build hacia otra imagen con la ayuda de la primera
FROM node:18-alpine3.15 AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN yarn build

IMPORTANTE: si no hago estos dos pasos cada vez que haga un build me va a descargar todos los modulos de node y son muchas dependencias.Es un standar separar en dos imagenes ya el proceso( y tmb llamar deps a la imagen de dependencias y builder a la imagen segunda).

#PASO TRES: el runner corre la aplicación:
FROM node:18-alpine3.15 AS runner

# Set working directory
WORKDIR /usr/src/app

COPY package.json yarn.lock ./

RUN yarn install --prod

COPY --from=builder /app/dist ./dist

# Copiar el directorio y su contenido
RUN mkdir -p ./pokedex

COPY --from=builder ./app/dist/ ./app
COPY ./.env ./app/.env

# # Dar permiso para ejecutar la applicación
RUN adduser --disabled-password pokeuser
RUN chown -R pokeuser:pokeuser ./pokedex
USER pokeuser

EXPOSE 3000

CMD [ "node","dist/main" ]

Sin embargo,si bien se recomienda usar esta aproximación y no la primera,aun estamos con lo mismo en cuanto a la db.Lo que vamos a hacer es crear un docker-compose.prod:

version: '3'

services:
  pokedexapp:
    depends_on:
      - db
    build: 
      context: .
      dockerfile: Dockerfile.prod
    image: pokedex-docker
    container_name: pokedexapp
    # restart: always # reiniciar el contenedor si se detiene
    ports:
      - "${PORT}:${PORT}" # es el PORT del .env luego es 3000:3000,o sea que saco la API por el 3000 de mi maquina desde el 3000 del container
    # working_dir: /var/www/pokedex
    environment:
      MONGODB: ${MONGODB}
      PORT: ${PORT}
      DEFAULT_LIMIT: ${DEFAULT_LIMIT}
    # volumes:
    #   - ./:/var/www/pokedex

  db:
    image: mongo:5
    container_name: mongo-poke #esto es un DNS resolvible 
    # restart: always
    ports:
      - 27021:27017
    environment:
      - MONGO_INITDB_DATABASE=nest-pokemon
      - MONGO_INITDB_ROOT_USERNAME=root
      - MONGO_INITDB_ROOT_PASSWORD=root
    volumes:
      - ./init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
    # volumes: 
    #   - ./mongo:/data/db <- ojo con el ./mongo en Linux

Fijate que cada image es un DNS.Docker va a saber resolver ese name a una IP,luego la URI va a ser asi:
MONGODB="mongodb://root:root@mongo-poke:27017/nest-pokemon" <- cambia a 17 ojo
Debo recordar que container-name es un DNS resolvible para Docker

NOTA: fijate que la primera vez he ejecutado:
>docker-compose -f <file> --env-file <env> up --build
* siempre que quiera reconstruir todo por cambios en el code tengo que pasarle --build,pero si no he hecho cambios no necesito la flag

			VIDEO 113 MANTENER VOLUMEN Y ANALIZAR LA IMAGEN

Obviamente no queremos estar perdiendo la base de datos cada vez que paremos el contenedor.Necesitaremos engancharla un volumen:

  db:
    image: mongo:5
    container_name: mongo-poke #esto es un DNS resolvible 
    # restart: always
    ports:
      - 27021:27017
    environment:
      - MONGO_INITDB_DATABASE=nest-pokemon
      - MONGO_INITDB_ROOT_USERNAME=root
      - MONGO_INITDB_ROOT_PASSWORD=root
    volumes:
      - ./init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
      - /mongo:/data/db # <- ojo con ./mongo en Linux y permisos

Recuerda que container_name es resolvible.Muy interesante.Lo suyo sería meterle la interfaz mongo-express también,ya lo haré.

Recuerda actualizar el README para un ambiente de prod.

				SECCION 10 TYPEORM - POSTGRESQL

En esta sección estaremos trabajando con:

1- TypeORM
2- Postgres
3- CRUD
4- Constrains
5- Validaciones
6- Búsquedas
7- Paginaciones
8- DTOs
9- Entities
10- Decoradores de TypeORM para entidades
11- Métodos BeforeInsert, BeforeUpdate

Es una sección importante porque a partir de aquí, empezaremos a construir sobre ella relaciones, autenticación, autorización y websockets.

NOTA: TypeORM se integra muy bien con Nest.Recuerda que como es una app nueva tengo que desinstalar el linter y el prettier,que está muy agresivo.Y la carpeta .git también.


