				SECCION 07 MONGODB POKEDEX

Vamos a empezar a grabar y leer de DB,usaremos un contenedor de Docker.Esta sección enteramente se enfoca en la grabación a base de datos, pero puntualmente:

1- Validaciones
2- CRUD contra base de datos
3- Docker y Docker Compose
4- Conectar contenedor con filesystem (para mantener la data de la base de datos)
5- Schemas
6- Modelos
7- DTOs y sus extensiones
8- Respaldar a Github

			VIDEO 68 INICIO PROYECTO POKEDEX

Creo un nuevo proyecto 'nest new pokedex'.En esta seccion veré como crear un registro de logs de errores,crearemos un custom pipe y una conexión a base de datos.Más adelante haremos lo mismo con PostgreSQL.
NOTA: fijate que puede que tenga que estar borrando todo lo relacionado a prettier

			VIDEO 69 SERVIR CONTENIDO ESTÁTICO

Es muy común ofrecer contenido http al acceder a las urls de mi app(normalmente se sirve una aplicación web,o una pagina web).

Nosotros podemos servir contenido estático con Nest,aunque tenemos que añadir una dependencia y crear la carpeta 'public' en la raiz del proyecto:
>yarn add @nestjs/serve-static

Adicionalmente hay que configurar la app,en el app.module(el modulo más arriba),diciendole donde está ese directorio publico:

* En el app.module.ts le paso el rootPath hasta public:

import { Module } from '@nestjs/common';
import { ServeStaticModule } from '@nestjs/serve-static';
import { join } from 'path';

@Module({
  imports: [
    ServeStaticModule.forRoot({
      rootPath: join(__dirname,'..','public')
    })
  ],
})
export class AppModule {}

Fijate que sólo con esto ya puedo embeber aqui una aplicación de Angular,React,Vue,etc y servirla.

			VIDEO 70 GLOBAL PREFIX

Es muy comun que toda mi app tenga el prefijo /api o /api/v1.Empecemos creando el resource pokemon:
>nest g res pokemon --no-spec

Si ahora voy a Postman puedo ir a /pokemon etc,pero de nuevo es muy comun que sea /api/pokemon.Realmente sería simplemente agregar esto al decorador @Controller:

@Controller('api/pokemon')

Pero podemos configurar globalmente esto,para no repetirlo en cada controlador,basta usar el método app.setGlobalPrefix(string):


async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.setGlobalPrefix('api');
  await app.listen(3000);
}

Y faltaria agregar el versionamiento de la api:
  app.enableVersioning({
    type: VersioningType.URI,
    defaultVersion: '1',
  });

Ahora si,tendré que apuntar a /api/v1/ primero.

				VIDEO 71 DOCKER - DOCKER-COMPOSE MONGO-IMAGE

Copiar un  docker compose con la imagen mongo 5.0.0(importante que ya la tengo).Fijate que necesitó de un param en la MongoURI.

				VIDEO 72 CREAR README

Fijate que importante es crear el Readme.Vamos a dejar el icono y crear una lista ordenada con (1. 2. 3. ) y de bullets con *:

# Ejecutar en desarrollo

1. Clonar el repositorio
2. Ejecutar
```
yarn install
```
3. Se requiere tener Nest CLI instalado
```
npm i -g @nestjs/cli
```
4. Levantar la base de datos(la MONGOURI necesita ?authSource=admin)
```
docker-compose up -d
```

## Stack usado
* MongoDB
* Nest
* ODM Mongoose

Fijate que es importante recalcar el stack usado.

		VIDEO 73 CONECTORES NATIVOS DE NEST

Nest se puede conectar a casi cualquier base de datos,siempre y cuando haya algun adaptador/libreria que lo permita.Usaremos mongoose,pero con un adaptador extra para nest.Este paquete wrapper que se pone encima de mongoose añade funcionalidad extra como mejor manejo de errores,poder usar inyección de dependencias,entities,etc, asi que es totalmente necesario instalar ambos:
>npm install @nestjs/mongoose mongoose

Posteriormente usaremos TypeORM para Postgre.Perfecto.

NOTA: hay que ir al main.ts y traerse el MongooseModule y pasarle una MongoURI.

En el main.ts
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [MongooseModule.forRoot('mongodb://localhost/nest')],

TIP:si la base de datos no esta UP ni siquiera funcionarán los controladores.

				VIDEO 74 CREAR ESQUEMAS Y MODELOS

Cuando estoy trabajando con MongoDB,el gestor me va a proporcionar un id único a nivel mundial(uu).Bien,para enlazar la entidad usaré el decorador @Schema,de forma similar a @Entity en Spring:

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema()
export class Pokemon extends Document {
  @Prop({
    unique: true,
    index: true, //queremos un index para optimizar busquedas sobre el name
  })
  name: string;
  @Prop({
    unique: true,
    index: true,
  })
  no: number;
}

export const PokemonSchema = SchemaFactory.createForClass(Pokemon);

Fijate que tengo que crear el Schema desde la Factory y que cada columna le estoy creando un indice,ya que queremos buscar por name o por no.Además,son únicas.

IMPORTANTE: aun falta otro paso importante,y es definir los modelos.Esta vez se hace en el modulo correspondiente(en este caso en pokemon.module):

@Module({
  controllers: [PokemonController],
  providers: [PokemonService],
  imports: [
    MongooseModule.forFeature([{
      name:Pokemon.name, // la entidad
      schema: PokemonSchema
    }])
  ]
})
export class PokemonModule {}

Fijate que es forFeature y que necesita el Schema y el name.Bastante sencillo.
Esto ya deberia crear una colección,aunque puede que necesite insertar un documento para verla.

			VIDEO 75 POST - RECIBIR Y VALIDAR LA DATA 

Fijate que para las validaciones lo primero será instalar las librerias class-transformer y class-validator:
yarn add class-transformer class-validator


export class CreatePokemonDto {
  @IsInt()
  @IsPositive()
  @Min(1, { message: 'number must be minimum 1' })
  no: number;

  @IsString()
  @MinLength(1, { message: 'string must have at least 1 ch' })
  name: string;
}

			VIDEO 76 CREAR POKEMON EN BASE DE DATOS

Para poder interactuar con el Modelo vamos a tener que inyectar una instancia de tipo Model<Entity>.Realmente ya tenemos todo echo:

 constructor(
    @InjectModel(Pokemon.name)
    private readonly pokemonModel:Model<Pokemon>
    ){}
Fijate que Pokemon es la Entity y que el decorador recibe el name como argumento.Este decorador @InjectModel lo hizo la gente de Nest para que pueda inyectar modelos en un Service(u otra clase).

Ahora si,ya podemos grabar en DB.Realmente lo único que tengo que tener en cuenta es que es una acción asíncrona y tengo que etiquetar el método como async,que no lo estaba(ojo que todos vienen sin async):

  async create(createPokemonDto: CreatePokemonDto) {
    createPokemonDto.name = createPokemonDto.name.toLowerCase();
    
    const pokemon = await this.pokemonModel.create(createPokemonDto);

    return pokemon;
  }

Ahora,si,ya puedo guardar en la dB mi primer documento.Fijate que si vuelvo a intentar guardar el mismo me dará un 500 por que el name es unique.Tenemos que gestionar mejor estos errores.

			VIDEO 77 RESPONDER A UN ERROR ESPECIFICO

Fijate que mongoose me esta dando un Error 11000 Duplicate Key.Si lo imprimo veré esto:
{
  index: 0,
  code: 11000,
  keyPattern: { name: 1 },
  keyValue: { name: 'bulbasaur' },
  [Symbol(errorLabels)]: Set(0) {}
}
Puedo acceder al keyValue para evitar tener que hacer una consulta a la DB.
  
async create(createPokemonDto: CreatePokemonDto) {
    createPokemonDto.name = createPokemonDto.name.toLowerCase();

    try {
      const pokemon = await this.pokemonModel.create(createPokemonDto);
      return pokemon;
    } catch (error) {
      if(error.code === 11000){
        throw new BadRequestException(`Pokemon already exists on DB ${JSON.stringify(error.keyValue)}`)
      }
      console.log(error);
      throw new InternalServerErrorException(`Can't create Pokemon - Check server logs`)
    }
  }

Fijate que debo aprovecharme de estar en la exception Zone.Por último,puedo mandar cualquier StatusCode,tanto poniendo el numero en bruto como usando constantes:

  @Post()
  @HttpCode(200) <- también puedo usar HttpStatus.OK
  create(@Body() createPokemonDto: CreatePokemonDto) {
    return this.pokemonService.create(createPokemonDto);
  }

Es buena idea usar el diccionario de constantes.

		VIDEO 	78 FIND ONE BY ID - BUSCAR POR MONGO ID,NAME O NO

La Api Pokedex ya tiene echos los endpoints para buscar por MongoId,o cualquier campo.Tendremos que ver de que tipo es el param pues:

  async findOne(param: string) {
    let pokemon: Pokemon;
    //si el param  es un no
    if (!isNaN(+param)) {
      // ojo que moongose va a convertir param a number,no hace falta hacerlo
      pokemon = await this.pokemonModel.findOne({ no: param });
    }
    //si el param  es un mongoId
    if (!pokemon && isValidObjectId(param)) {
      pokemon = await this.pokemonModel.findById(param);
    }
    //si el param  es un string
  if (!pokemon) {
      pokemon = await this.pokemonModel.findOne({ name: param });
    } 
	// si no encontramos nada ya si lanzamos un 404
  if(!pokemon){
      throw new NotFoundException(`Pokemon with id,name or no ${param} not found`)
    }
    return pokemon;
  }
Fijate que NotFoundException tira un 404,no confundir una BadRequest que es un 400 con un 404 que es NoContent.

Y observa como hemos usado la función de mongoose isValidObjectId.Genial

				VIDEO 79 ACTUALIZAR POKEMON EN BD

Fijate la importancia de ya tener bien hecho el getOne,asinto:

  async update(term: string, updatePokemonDto: UpdatePokemonDto) {
    // fijate la importancia de llamar en el update al getOne,esto es un estandar y una buena practica
    const pokemon = await this.findOne(term);
    // si llegamos aqui es que he encontrado un pokemon
    if (updatePokemonDto.name) {
      updatePokemonDto.name = updatePokemonDto.name.toLowerCase();
    }
    try {
      await this.pokemonModel.findOneAndUpdate(
        { _id: pokemon._id },
        updatePokemonDto,
      );
      return { ...pokemon.toJSON(), ...updatePokemonDto };
    } catch (error) {
      this.handleExceptions(error);
    }
  }

			VIDEO 81 ELIMINAR UN POKEMON - CUSTOM PIPE 

Realmente queremos que el param sea un MongoId y borrar solo por Id.Crearemos un custom pipe para ello.Este pipe deberia vivir en un lugar global,ya que vale comprobar un mongoId vale para toda la app.
Fijate que Nest ya recomienda crear una carpeta commons para cosas como esta,asi que primero creo el modulo y despues el pipe:

>nest g mo common
>nest g pi common/pipes/parseMongoId <- nombre de la clase


Esto creará una clase con el decorador @Injectable que implementa la interfaz PipeTransform.Todo pipe implementa esta interfaz y debe desarrollar el método abstracsto transform(value,metadata)

@Injectable()
export class ParseMongoIdPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}

IMPORTANTE: los pipes transforman la data,no sólo visualmente,realmente transforman la data,esto es muy importante.
Bien,además que siempre hay que retornar el valor,ya sea modificado o no,con todo esto puedo crearme un Pipe para asi reusarlo masivamente.Genial:

@Injectable()
export class ParseMongoIdPipe implements PipeTransform {
  transform(value: string, metadata: ArgumentMetadata) {
    // console.log({value,metadata})
    if(!isValidObjectId(value)){
      throw new BadRequestException(`${value} is not a valid MongoId`)
    }
    return value;
  }
}

			VIDEO 83 VALIDAR Y ELIMINAR EN UNA SOLA OPERACIÓN	

Podemos mirar la cuenta de los documentos que se borran y si es 0 lanzar un 400 ya que estamos en un Service.Genial:

  async remove(id: string) {
    const { deletedCount } = await this.pokemonModel.deleteOne({ _id: id });
    if( deletedCount === 0) {
      throw new BadRequestException(`Pokemon with id ${id} not found`);
    }
    return;
  }

			SECCION 08 SEED-DATA Y PAGINACION		

Esta sección tiene por objetivo aprender:

1- Uso de modelos en diferentes módulos
2- SEED para llenar la base de datos
3- Paginación de resultados
4- DTOs para Query parameters
5- Transformaciones de DTOs

También les mostraré varias formas de hacer inserciones por lote y varias formas de lograrlo.

			VIDEO 89 CREAR MODULO SEED

Creamos un recurso y dejamos solo el GET.Usaremos axios:
Fijate que él tomó una aproximación diferente ya que exportó el MongooseModule en vez de el service:

  exports:[PokemonService,MongooseModule]
})
export class PokemonModule {}
Realmente solo queria que vieramos que podemos exportar el modulo o el servicio.Obviamente es mejor exportar el servicio ya que tiene las validaciones,etc...

NOTA: tenemos un problema si fueran miles de registros ya que no estamos usando paralelismo,pero podemos hacerlo y deberiamos.

		VIDEO 93 INSERTAR VARIOS REGISTROS SIMULTANEAMENTE-EN PARALELO

Una forma sería con Promise.all y anteriormente metiendo el create en cada posición.
   // forma uno
      insertPromisesArray.push(this.pokemonService.create({name,no}))
      await Promise.all(insertPromisesArray)

Sin embargo hay una forma mejor,con insertMany:

    const pokemonToInsert: { name: string; no: number }[] = [];

    data.results.forEach(async ({ name, url }) => {
      const segments = url.split('/');
      const no: number = +segments[segments.length - 2];
      // forma uno
      // insertPromisesArray.push(this.pokemonService.create({name,no}))
      // await Promise.all(insertPromisesArray)

      // forma dos
      pokemonToInsert.push({ name, no });
      // await this.pokemonService.create({ name, no });
    });
    await this.pokemonModel.insertMany(pokemonToInsert)
    return data;
Recuerda que el MongooseModule lo inyecté asi:
@InjectModel(Pokemon.name)
private readonly pokemonModel: Model<Pokemon>

NOTA: normalmente este endpoint estará restringido,etc

				VIDEO 94 CREAR UN CUSTOM PROVIDER

Ya hemos comentado que la clase SeedService tiene la dependencia de axios,y por ello está acoplada a esta libreria.Sería mejor abstraer esta lógica de la clase y poder cambiar axios por fetch mediante el principio de sustitución de Liskov.

Recuerda que un Provider tiene que estar definido en el módulo más cercano y que todo Provider puede ser inyectado(de ahi su nombre,puede ser proveido)

Realmente es muy sencillo crear una abstración de Axios o fetch.Lo primero es crear la abstracción.Usaremos una interface:

export interface HttpAdapter {
  get<T>(url:string):Promise<T>; <- y asi para los 4 verbos
}

Despues creo las implementaciones,recuerda que debo anotarlas con @Injectable.

@Injectable()
export class AxiosAdapter implements HttpAdapter {
  private readonly axios:AxiosInstance = axios;

  async get<T>(url:string):Promise<T> {
    try{
      const {data} = await this.axios.get<T>(url);
      return data;
    } catch(error) {
     throw new Error('This is an error'); <- habria que gestionar mejor el error  	
IMPORTANTE: recuerda que es un Provider y que estoy en otro modulo,tengo que declararlo como Provider y además exportarlo( y además importar este modulo despues en cada otro modulo que quiera usar este provider) para poder inyectarlo en el SeedModule:

@Module({
  providers: [AxiosAdapter],
  exports: [AxiosAdapter]
})
export class CommonModule {}

Y recuerda, tengo que importar este modulo en el SeedModule:

@Module({
  imports:[PokemonModule,CommonModule],
  controllers: [SeedController],
  providers: [SeedService]
})
export class SeedModule {}


Ya sólo queda usarlo,inyectando el axiosAdapter,que será intercambiable(fijate que inyecto la implementación,pero es intercambiable al extender la interfaz por cualquier otra que tmb la implemente).Perfecto.

 constructor(
    @InjectModel(Pokemon.name)
    private readonly pokemonModel: Model<Pokemon>,
    private readonly pokemonService: PokemonService,
    private readonly axiosAdapter: AxiosAdapter,
  ) {}

  async executeSeed() {
    const data = await this.axiosAdapter.get<PokeResponse>(
      'https://pokeapi.co/api/v2/pokemon?limit=650',
    );

				VIDEO 95 PAGINACION DE POKEMONS

 La API oficial de Pokemon permite mandarle dos queryParams para la paginación:
https://pokeapi.co/api/v2/pokemon?offset=20&limit=20

Dado que vamos a pasarlos por los query parameters vamos a necesitar el decorador @Query,que rescata todos los parametros de la query de una request:

  @Get()
  findAll(@Query() queryParameters) {
    console.log(queryParameters);
    return this.pokemonService.findAll();
  }
NOTA: queryParameters es un objeto.Cada propiedad será un query param.Fijate que tenemos que validarlos,si necesitamos un offset y un limit deben ser de tipo number,etc
Asi podremos hacer this.pokemonModel.find().limit(limit).skip(offset);
Vamos a crearnos un dto para este objeto queryParameters con estas validaciones.
Esta clase va a lucir asi con las validaciones:

export class PaginationDto {

  @IsOptional()
  @IsPositive()
  @Min(1)
  limit:number;

  @IsOptional()
  @IsPositive()
  offset:number;
}

Sin embargo,si intento ir a https://localhost:3000/api/v1/pokemon?limit=10 veré que llega como un string y me viene un BadRequest

			VIDEO 96 TRANSFORMING PAGINATION-DTO

En nuestro main.ts puedo hacer una configuración global para que los dtos transformen la data a lo que estan esperando.Esto es un poco más costoso. Para ello basta con usar dos propiedades más,transform y transformOptions:

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, //filtra las propiedades
      forbidNonWhitelisted: true, //lanza 400 si vienen de más
      transform:true, // permitir que los dtos transformen la data
      transformOptions:{
        enableImplicitConversion:true
      }
    }),
  );

Ahora si,con esta configuración ya tengo los argumentos necesarios para pasarlos del controller al service:
  
@Get()
  findAll(@Query() {offset,limit}:PaginationDto) {
    return this.pokemonService.findAll(offset,limit);
  }

Y el service simplemente llama al limit y skip con estos datos:
  async findAll(offset: number = 0, limit: number = 10) {
    return this.pokemonModel.find()
      .limit(limit)
      .skip(offset)
      .sort({no:1})
      .select('-__v');
  }
En la siguiente sección vamos a desplegar todo esto,usando Docker tmb.

		SECCIÓN 9 CONFIGURAR VARIABLE DE ENTORNO Y DESPLIEGUE CON DOCKER

Vamos a desplegar con Heroku.Crearemos un docker-compose con una composición de una imagen de Mongo y otra de Nest,muy interesante.
En esta sección trabajaremos en la configuración de variables de entorno y su validación:
Puntualmente veremos:

1- Dockerizacion
2- Mongo Atlas
3- Env file
4- joi
5- Validation Schemas
6- Configuration Module
7- Recomendaciones para un Readme útil
8- Despliegues
9- Dockerfile

Fijate que aún no hemos creado ningun .env para variables de entorno.

			VIDEO 101 VARIABLES DE ENTORNO

Obviamente nos hemos dejado literales como el puerto o la MongoURI que deberían estar en variables de entorno.
Normalmente van en la raiz del proyecto en un archivo .env.Sin embargo,nest no va a leer el archivo .env sólo por crearlo, a diferencia de Express.

Para que Nest pueda leer el .env hay que instalar el modulo @nestjs/config:
>yarn add @nestjs/config

Y en el app.module hay que importar el modulo:
@Module({
  imports: [ ConfigModule.forRoot() ]

Ojo,que este modulo tiene que estar encima de por ejemplo este,ya que lleva el ConfigModule como dependencia:
   MongooseModule.forRoot(process.env.MONGODB, {
      authSource: 'admin',
    }),

				VIDEO 102 CONFIGURATION LOADER

Adicionalmente al ConfigModule también se recomienda que si voy a hacer uso dentro de un building block(un servicio,un controlador) de una variable de entorno,que lo haga mediante un Servicio.
En Nest es común crear un objeto con las env que quiero,mapeandolas:

En /config/app.config.ts:
export const EnvConfiguration = () => ({
  // variable que me dice el entorno
  environment : process.env.NODE_ENV === 'dev',
  mongodb: process.env.MONGODB,
  port: process.env.PORT || 3001,
  defaultLimit: process.env.DEFAULT_LIMIT || 7,
})

Y para que lo lea se lo paso en el forRoot(load:[object]):
 ConfigModule.forRoot({
      load:[EnvConfiguration] < -fijate que es un array de objetos
  }),

Ahora si,ya podemos usar el Servicio que ofrece el configModule y recomiendan

			VIDEO 103 CONFIGURATION SERVICE

En el momento en que intente inyectar ese servicio veré que tengo que declararlo como Provider en ese modulo:

  constructor(
    @InjectModel(Pokemon.name)
    private readonly pokemonModel: Model<Pokemon>,
    private readonly configService: ConfigService
  ) { }

  imports: [ConfigModule] <- tengo que importar el configModule en el modulo que inyecte el servicio

Ahora si,ya puedo usar su método get<T> de la clase del servicio para acceder a mi config.Fijate que me viene incluso como numero.

    private readonly configService: ConfigService) { 
    console.log(this.configService.get<number>('defaultLimit'))
  }

Y cabe recalcar que en los building blocks tengo que usar el servicio(es obligatorio o solo opcional),pero en el main.ts no estoy en un building block y puedo usar process.env:

En el main.ts:
  await app.listen(process.env.PORT, () => {
    console.clear();
    console.log('listening on port ' + process.env.PORT);
  });

		VIDEO 104 VALIDATION-SCHEMA PARA LAS ENV - JOI LIBRARY

Recuerda que Subject y sus derivados son todas multicasting(Behaviour además necesita un valor inicial y la otra guarda un registro de las emisiones y se las da acualquier nuevo observer que se una)

Siempre que quiera ser más estricto con la validación de un tipo(en este caso es un simple objeto,fijate que no tiene nada que ver con formularios9 puedo instalar joi(npm i joi).Anteriormente era hapi/joi,pero recomiendan pasarse ya a joi

import * as Joi from 'joi';

// debo crearme un Schema de validación
export const JoiValidationSchema = Joi.object({
  MONGODB: Joi.required(),
  PORT:Joi.number().default(3005),
  DEFAULT_LIMIT: Joi.number().default(6)
})

Afortunadamente,le puedo pasar este schema al ConfigModule en la propiedad validationSchema.

@Module({
  imports: [
    ConfigModule.forRoot({
      load:[EnvConfiguration],
      validationSchema:JoiValidationSchema
  }),

Ahora si,esta aplicación va a necesitar la variable MONGODB,por ejemplo,ya que es required,las otras dos como tienen un default()no necesitan ser required().

				VIDEO 105 ARCHIVO ENV-TEMPLATE

Realmente no es buena idea no comunicar como lucen las variables de entorno.FH recomienda crear un .env.template,e incluso se pueden llenar algunas o dar una pequeña descripcion:

MONGODB= la URI
PORT=se espera el 3000
DEFAULT_LIMIT= se espera 10

También se recomienda decir en el README.md que existe el archivo y debe configurarse

DESPLIEGUE A HEROKU: fijate que FH tuvo problemas por estar usando yarn ya que heroku necesita npm.REcuerda tmb que tengo que meter las variables de entorno desde la plataforma,de forma parecida a con Vercel.

				VIDEOS 109-110 DOCKERIZAR LA APP

Vamos a crear un compose,no solo con la imagen de mongo,sino tmb con la de node,asi,al hacer docker-compose up levantaré toda la app(y no solo la db).En resumen haremos un contenedor con toda la app.

Bien,volviendo al video,fijate que vamos a usar las flags -f(file) en el comando docker-compose(ya que voy a tener varios yaml).Muy interesante:
>docker-compose -f docker-compose.prod.yaml (up -d,stop,etc...)
* Simplemente va como primer argumento.

Y no solo eso,sino que como abstraeremos las env variables tamb le puedo pasar unenvFile con --env-file:
>docker-compose -f docker-compose.prod.yaml --env-file .env.prod up -d <- Muy PRO

NOTA: por defecto docker usa el .env por lo que si solo tengo este file no necesito pasarle la flag --env-file

A continuación FH muestra como ejecutar un script de node con un contenedor,de forma simple pero muy acertada:

FROM node:18-alpine3.15

# Set working directory
RUN mkdir -p /var/www/pokedex
WORKDIR /var/www/pokedex

# Copiar el directorio y su contenido
COPY . .
COPY package.json tsconfig.json tsconfig.build.json ./
RUN yarn install --prod
RUN yarn build


# Dar permiso para ejecutar la applicación
RUN adduser --disabled-password pokeuser
RUN chown -R pokeuser:pokeuser /var/www/pokedex
USER pokeuser

# Limpiar el caché
RUN yarn cache clean --force

EXPOSE 3000

CMD [ "yarn","start" ]

Fijate que crea un user para bajar privilegios,y también es agnostico a si se usa TS o JS,etc(claro que el yarn start debe saber lo que hace).
Además,normalmente voy a empaquetar una DB tmb con el script.

	VIDEO 111 DEFINIR LA COMPOSICIÓN DE LA IMAGEN PARA EL SCRIPT REST  + LA DB

Vamos a seguir otra aproximación mejor.Primero instalo sólo las dependencias de mi app con estas lineas:

#PASO UNO:crear una imagen solo con las dependencias y darla un name
FROM node:18-alpine3.15 AS deps

RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile

Despues,en un segundo paso construyo la app con la ayuda de esa primera image(recuerda que FROM crea una imagen):

# PASO DOS: hacer el build hacia otra imagen con la ayuda de la primera
FROM node:18-alpine3.15 AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN yarn build

IMPORTANTE: si no hago estos dos pasos cada vez que haga un build me va a descargar todos los modulos de node y son muchas dependencias.Es un standar separar en dos imagenes ya el proceso( y tmb llamar deps a la imagen de dependencias y builder a la imagen segunda).

#PASO TRES: el runner corre la aplicación:
FROM node:18-alpine3.15 AS runner

# Set working directory
WORKDIR /usr/src/app

COPY package.json yarn.lock ./

RUN yarn install --prod

COPY --from=builder /app/dist ./dist

# Copiar el directorio y su contenido
RUN mkdir -p ./pokedex

COPY --from=builder ./app/dist/ ./app
COPY ./.env ./app/.env

# # Dar permiso para ejecutar la applicación
RUN adduser --disabled-password pokeuser
RUN chown -R pokeuser:pokeuser ./pokedex
USER pokeuser

EXPOSE 3000

CMD [ "node","dist/main" ]

Sin embargo,si bien se recomienda usar esta aproximación y no la primera,aun estamos con lo mismo en cuanto a la db.Lo que vamos a hacer es crear un docker-compose.prod:

version: '3'

services:
  pokedexapp:
    depends_on:
      - db
    build: 
      context: .
      dockerfile: Dockerfile.prod
    image: pokedex-docker
    container_name: pokedexapp
    # restart: always # reiniciar el contenedor si se detiene
    ports:
      - "${PORT}:${PORT}" # es el PORT del .env luego es 3000:3000,o sea que saco la API por el 3000 de mi maquina desde el 3000 del container
    # working_dir: /var/www/pokedex
    environment:
      MONGODB: ${MONGODB}
      PORT: ${PORT}
      DEFAULT_LIMIT: ${DEFAULT_LIMIT}
    # volumes:
    #   - ./:/var/www/pokedex

  db:
    image: mongo:5
    container_name: mongo-poke #esto es un DNS resolvible 
    # restart: always
    ports:
      - 27021:27017
    environment:
      - MONGO_INITDB_DATABASE=nest-pokemon
      - MONGO_INITDB_ROOT_USERNAME=root
      - MONGO_INITDB_ROOT_PASSWORD=root
    volumes:
      - ./init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
    # volumes: 
    #   - ./mongo:/data/db <- ojo con el ./mongo en Linux

Fijate que cada image es un DNS.Docker va a saber resolver ese name a una IP,luego la URI va a ser asi:
MONGODB="mongodb://root:root@mongo-poke:27017/nest-pokemon" <- cambia a 17 ojo
Debo recordar que container-name es un DNS resolvible para Docker

NOTA: fijate que la primera vez he ejecutado:
>docker-compose -f <file> --env-file <env> up --build
* siempre que quiera reconstruir todo por cambios en el code tengo que pasarle --build,pero si no he hecho cambios no necesito la flag

			VIDEO 113 MANTENER VOLUMEN Y ANALIZAR LA IMAGEN

Obviamente no queremos estar perdiendo la base de datos cada vez que paremos el contenedor.Necesitaremos engancharla un volumen:

  db:
    image: mongo:5
    container_name: mongo-poke #esto es un DNS resolvible 
    # restart: always
    ports:
      - 27021:27017
    environment:
      - MONGO_INITDB_DATABASE=nest-pokemon
      - MONGO_INITDB_ROOT_USERNAME=root
      - MONGO_INITDB_ROOT_PASSWORD=root
    volumes:
      - ./init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
      - /mongo:/data/db # <- ojo con ./mongo en Linux y permisos

Recuerda que container_name es resolvible.Muy interesante.Lo suyo sería meterle la interfaz mongo-express también,ya lo haré.

Recuerda actualizar el README para un ambiente de prod.

				SECCION 10 TYPEORM - POSTGRESQL

En esta sección estaremos trabajando con:

1- TypeORM
2- Postgres
3- CRUD
4- Constrains
5- Validaciones
6- Búsquedas
7- Paginaciones
8- DTOs
9- Entities
10- Decoradores de TypeORM para entidades
11- Métodos BeforeInsert, BeforeUpdate

Es una sección importante porque a partir de aquí, empezaremos a construir sobre ella relaciones, autenticación, autorización y websockets.

NOTA: TypeORM se integra muy bien con Nest.Recuerda que como es una app nueva tengo que desinstalar el linter y el prettier,que está muy agresivo.Y la carpeta .git también.

				VIDEOS 119-120 CONECTAR LA DB DE POSTGRES

Ya tengo mi docker-compose que además levanta una GUI.Usaré ese.Lo siguiente es conectar Nest con Postgres.Fijate que para ello necesitaré instalar la libreria core typeorm y su libreria adapter @nestjs/typeorm(basicamente son todos los decoradores) y el driver(pg)

>npm install @nestjs/typeorm typeorm pg

Recuerda que en Nest para leer el .env necesito el modulo ConfigModule.
>yarn add @nestjs/config

Y en el app.module.ts
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [ConfigModule.forRoot()],
  controllers: [],
  providers: [],
})
export class AppModule {}

Ahora si,instalo y configuro el ORM:
yarn add @nestjs/typeorm typeorm pg <- si me dejará el adapter veré un Error que me lo pide.

Ya solo es configurar este modulo TypeORMModule:

@Module({
  imports: [
    ConfigModule.forRoot(),
    TypeOrmModule.forRoot({
      type:'postgres',
      host: process.env.DB_HOST,
      port: +process.env.DB_PORT,
      database: process.env.DB_NAME,
      username: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD,
      autoLoadEntities:true,
      // synchronize resincroniza cualquier cambio en las entidades(agregar una columna,etc),es algo que no querré en producción,pero si en desarrollo.Normalmente en prod se hacen migraciones,no se toca la db asi por asi
      synchronize:true 
    })
  ],

NOTA: fijate que esta vez no vamos a validar el archivo .env,como en la app anterior,contra un objeto etc.Desde luego se hará en empresas,pero ahora no es necesario.Fijate tmb que el puerto es el 5433 esta vez.

			VIDEO 121 TYPEORM - ENTITY PRODUCT

Recuerda que el slug es un string sin espacios que me sirve para crear URLs amigables.Por ejemplo:
slug: "mens_chill-crew_neck_sweatshirt"

Vamos a usar el Product del curso de Next,asi que ya sé como luce.
IMPORTANTE: de igual manera que tuve que anotar con @Schema para Mongoose ahora tengo que anotar con @Entity por ser SQL:

@Entity()
export class Product {

  @PrimaryGeneratedColumn()
  id: number;

}
NOTA: muchas veces se trabaja con numeros enteros autoincrementales,y lo vamos a hacer,pero esta vez queremos usar un uuid.Esta libreria typeorm trae soporte total para ello.

* Solo hay que indicar que será un uuid,claro que será un string entonces
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text',{ unique: true}) <- puedo decir que es un text y unique
  title: string;

Y de igual forma que con Mongoose tuve que crear un Schema de esta forma:
export const PokemonSchema = SchemaFactory.createForClass(Pokemon);
Y despues pasarlo en el modulo:
  imports: [
    MongooseModule.forFeature([{
      name:Pokemon.name, // la entidad
      schema: PokemonSchema
    }]),
    ConfigModule
  ],
  exports:[PokemonService,MongooseModule]
})
export class PokemonModule {}

Tengo que hacer lo mismo con SQL,aunque es más sencillo:
  imports: [TypeOrmModule.forFeature([Product])],
})
export class ProductsModule {}

Ahora si,ya puedo ir a la DB y ver como se crear la tabla Product con esas dos columnas(id y title).

				VIDEO 122 ENTIDAD SIN RELACIONES

Vamos a crear una nueva columna,fijate que en Postgre no existe el tipo 'number' sino que es 'float'(importante,numeric es un string??):

@Column('float',{default:0})
price: number;

De igual forma puedo pasarle array:boolean cuando sea un arreglo de elementos:
  @Column('text',{
    array: true
  })
  sizes: string[];

Y fijate que si quiero crear una columna 'stock' hay van enteros y no flotantes,luego no será numeric sino int:
  @Column('int',{default:0})
  stock: number;

				VIDEO 123 CREAR UN PRODUCTO - CreateProductDTO

select a.name,b.location from empleados a left join departamentos b on a.id = b.employee_id;
Bien,nuestro create-entity-dto va a lucir asi:

export class CreateProductDto {
  @IsString()
  @MinLength(3, { message: 'title must have at least 3 ch' })
  title: string;

  @IsNumber() @IsPositive() @IsOptional()
  price?: number;

  @IsString() @IsOptional()
  description?: string;
  
  
  @IsString() @IsOptional()
  slug?: string;

  @IsInt() @IsPositive() @IsOptional()
  stock?: number;

  @IsString({each:true})
  @IsArray()
  sizes: string[];

  @IsIn(['men','women','kids','unisex'])
  gender: string;
}

Fijate en el uso de IsNumber para el price y como difiere de IsInt para el stock,de igual manera que usamos numeric e int para la DB.
Fijate tmb en IsArray y en @IsIn([item,item,item]) como validaciones más avanzadas.

				VIDEO 124 INSERTAR UN PRODUCT USANDO EL DTO

Vamos a usar el patrón Repository para impactar la base de datos(con transacciones).Hay muchos beneficios al usar el patrón Repository.

IMPORTANTE: la gente de Nest ya pensó en esto y crearon una clase inyectable cuando use TypeORM.La sintaxis es:

 @InjectRepository(T)
private readonly entityRepository: Repository<T>

Donde T es la entidad(en este ejemplo Producto).No confundir con el DTO:

constructor(
  @InjectRepository(Product)
  private productRepository: Repository<Product>,
  ... resto de inyecciones

Para crear un objeto de una Entidad simplemente uso create + save:
  async create(createProductDto: CreateProductDto) {
    try {
      const product = this.productRepository.create(createProductDto)
      await this.productRepository.save(product)
    } catch (error) {
      console.log(error);
      throw new InternalServerErrorException('Error')
    }
  }
Ojo,que create es sincrono,el que es asincrono es save

				VIDEO 125 MANEJO DE ERRORES

IMPORTANTE: igual que en Spring,tengo una mejor forma de hacer console.logs.Fijate que siempre debo aspirar a usar loggers que amplien funcionalidad.En este caso,dado que el framework es una copia de Spring,tmb tiene una clase Logger ya pre-built la cual puedo instancia y hacer logger.warn() | logger.error(),etc:

  private readonly logger = new Logger('ProductsService');

   } catch (error) {
      this.logger.error(error);

Cuando salte ese error me dice la clase donde saltó.Fijate que la idea es extrapolable:

Nest running on port 3000
[Nest] 104312  - 11/08/2022, 18:13:50   ERROR [ProductsService] QueryFailedError: duplicate key value violates unique constraint "UQ_f7bf944ad9f1034110e8c2133ab"

Ahora si que son legibles los errores.Sin embargo,no debo parar solamente en un mejor formateo y visibilidad del error:
   
 } catch (error) {
      if (error.code === '23505') {
        throw new BadRequestException(error.detail);
      }
      this.logger.error(error);
      throw new InternalServerErrorException('Unexpected error, check server logs');
    }
  }
Es mejor que mire por el error.code y si es por Duplicate Key lo diga al developer de front.Y recuerda que no tiene sentido ir repitiendo esto por cada controlador.Debo no repetirme abstrayendolo a un método:

  private handleExceptions(error: any) {
    if (error.code === '23505') {
      throw new BadRequestException(error.detail);
    }
    this.logger.error(error);
    throw new InternalServerErrorException(
      'Unexpected error, check server logs',
    );
  }

catch(error){
  this.handleExceptions(error) <- perfecto
}

				VIDEO 126 BEFOREINSERT Y BEFOREUPDATE

Sin embargo,aun tenemos el problema del campo slug, ya que la DB lo necesita y en el DTO esta opcional.Porqué?Porque queremos generarlo,el slug es el title pero sin espacios,realmente no es necesario pedirlo(aunque lo pueden meter).

Bien,podemos hacerlo de forma guarra con un replaceAll(fijate que replaceAll necesita aumentar la opcion target de es201X hasta es2021).De esta forma Typescirpt permite usar replaceAll en strings tmb,y no sólo en arreglos:

  async create(createProductDto: CreateProductDto) {
    try {
      if(!createProductDto.slug){
        createProductDto.slug = createProductDto.title
        .toLowerCase()
        .replaceAll(' ','_')
        .replaceAll("'",'')
      }
Sin embargo,esto es muy básico,y además,si viene mal no va a entrar por el if.

NOTA: este código es muy común.Lo voy a repetir en otro punto,casi seguro,luego sería mejor sacarlo a un método,igual que el errorhandler.Pero realmente esta lógica está atada al proceso de guardar o actualizar en la DB.Podemos crear un procedimiento para esto y automatizar la tarea:

@Entity()
export class Product {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text', { unique: true })
  title: string;

  // procedures
  @BeforeInsert()
  checkSlug(): void {
    if (!this.slug) {
      this.slug = this.title
        .toLowerCase()
        .replaceAll(' ', '_')
        .replaceAll("'", '');
    }
  }
}

Fijate que al final lo dejamos asi:
  // procedures
  @BeforeInsert()
  checkSlug(): void {
    if (!this.slug) {
      this.slug = this.title;
    }
    this.slug = this.slug
      .toLowerCase()
      .replaceAll(' ', '_')
      .replaceAll("'", '');
  }
}

Desde luego es mucho más limpio.Más adelante veremos el @BeforeUpdate,ya que esté solo entra con el insert pues es @BeforeInsert.

				VIDEO 127 GET Y DELETE CON TYPEORM

My regards: mis saludos, regarding to: respecto a
Currently,I wasn't chosen despite being quite prehistoric

En cuanto a la tarea no puede ser más simple:


  async findOne(uuid: string) {
    const product = await this.productRepository.findOneBy({ id: uuid });
    if (!product) {
      throw new NotFoundException(`Product with id ${uuid} not found`);
    }
    return product;
  }

  async remove(id: string) {
    const deleteProduct = await this.productRepository.delete({ id: id });
    if(deleteProduct.affected === 0){
      throw new NotFoundException(`Product with id ${id} for deleting op not found`)
    }
  }

				VIDEO 128 PAGINAR EN TYPEORM

Queremos implementar la paginacion.Fijate que crear una paginacion es algo superbásico,y realmente no pertenece a products,sino a la app, asi que generaremos un modulo para ella:
>nest g mo common

Anteriormente hemos usado en el main.ts las propiedades transform y transformOptions para que el dto transformará la data.Vamos a ver otra forma de hacerlo.

IMPORTANTE: cualquier QueryParam que traiga con @Query lo traigo como string.Vale madre que hayamos declarado que la prop es un number en la clase:
  
@Get()
  findAll(@Query() pDto:PaginationDto) {
    console.log({pDto})
    return this.productsService.findAll();
  }

Si ahora hago un get a /api/v1/products?limit=10&offset=5 va a dar error,ya que son strings.Como son strings están chocando contra el @IsPositive.Ahora si,vamos a ver el decorador @Type,que es lo mismo que poner enableImplicitConversion a true,pero me deja más control que poner toda la app en true.

export class PaginationDto {

  @IsInt() @IsPositive() @IsOptional() @Type( () => Number)
  limit?: number;

  
  @IsInt() @IsPositive() @IsOptional() @Type( () => Number)
  offset?: number;

Ahora si,puedo rescatar las props limit y offset de las query del getAll

			VIDEO 129 BUSCAR POR SLUG O UUID

Si simplemente quisieramos esto es muy sencillo con la función validate de la libreria uuid:

 async findOne(term: string) {
    let product: Product;
    if(isUUID(term)){
      product = await this.productRepository.findOneBy({id:term});
    } else {
      product = await this.productRepository.findOneBy({slug:term});
    }
    if (!product) {
      throw new NotFoundException(`Product with term ${term} not found`);
    }
    return product;
  }

Sin embargo,vamos a añadir que se pueda buscar por el title,y es aqui donde vemos que puede haber espacios,que estamos expuestos a una inyección SQL,etc.
TypeORM ya nos previene de todo esto mediante el QueryBuilder

				VIDEO 130 QUERY BUILDER

Siempre llega un punto en que tenga que hacer una query un poco más compleja que lo normal.

NOTA: QueryBuilder escapa los caracteres especiales,evitando la inyección SQL.Además de usar consultas parametrizadas.

 // esta instancia de tipo QueryBuilder tiene acceso a todo,a la cadena de conexión,a las relaciones,...
  const queryBuilder = this.productRepository.createQueryBuilder();
  product = await queryBuilder
    .where('title =:title or slug =:slug',{
      title:term,
      slug:term,
    }).getOne()
    }

Fijate que queryBuilder necesita del await y del getOne | getMany | getXXX
Por último podriamos hacer que el term fuera insensitivo:

   const queryBuilder = this.productRepository.createQueryBuilder();
    product = await queryBuilder
      .where('UPPER(title) =:title or slug =:slug',{
        title:term.toUpperCase(),
        slug:term.toLowerCase(),
      }).getOne()

Aunque usar UPPER o LOWER o ILIKE romperá el indice que habiamos creado

				VIDEO 131 UPDATE EN TYPEORM

Tenemos ciertas restricciones,como que el slug debe lucir como un slug,o el title es unico,asi que no es un update muy básico.

TypeORM hace extremadamente sencillo los update,gracias al método preload,que es como un find + update(upsert??)
 
 async update(id: string, updateProductDto: UpdateProductDto) {
    // preload es un upsert,aunque falta el save
    const product = await this.productRepository.preload({
      id:id,
      ...updateProductDto
    })
    if(!product) {
      throw new NotFoundException(`Product with id ${id} not found`);
    }
    return await this.productRepository.save(product)
  }
Recuerda tmb que return await es redundante,el return ya hace de await.Un alumno comenta otra solución con QueryBuilder:
const result = await this.productRepository.createQueryBuilder().update({
  id:id,
  ...updateProductDto
)}.where({id}).execute()

Desde luego reduce el acceso a la DB a uno solo y está metido en un try catch.

Sin embargo,faltan las constraints,ya que no puedo modificar un title a un valor que ya existe,pues es unique:

    try {
      await this.productRepository.save(product)
      return product;
      
    } catch (error) {
      this.handleExceptions(error);
    }

			VIDEO 132 BEFORE UPDATE EN TYPEORM - procedures

NOTA: parece que el @BeforeUpdate y el queryBuilder trabajan de otra forma:

Hola gente, estaba tratando de hacer este mismo ejercicios de otra forma, hice la actualización con un queryBuilder. Actualiza las cosas, pero no aplica el @beforeUpdate() esto sucede porque según la documentación es necesario que se aplique el save para el afterUpdate y el beforeUpdate

const queryBuilder = await this.productRepository
          .createQueryBuilder()
          .update<Product>(Product, { ...updateProductDto })
          .where('id = :id', { id: id })
          .returning('*')
          .execute(); 

En cuanto al código luce asi:

  @BeforeUpdate()
  checkSlugB4Update(): void {
    this.slug = this.slug
      .toLowerCase()
      .replaceAll(' ', '_')
      .replaceAll("'", '');
  }

			VIDEO 133 NUEVA COLUMNA - TAGS

Es muy común tener una columna para realizar consultas rápidas por palabras clave en una app.

  @Column({
    type: 'text',
    array:true,
    default: []
    })
  tags: string[];

Obviamente también tengo que ir al createDTO:
 @IsString({each:true})
 @IsArray()
 tags:string[];

Por último FH recomienda crear un proyecto cascarón para cualquier proyecto futuro mio y dejarlo en un repo y despues bajarlo de ahi(tmb recomienda tener la auth).

			SECCION 11 RELACIONES ENTRE ENTIDADES EN TYPEORM

Vamos a crear la relacion entre las imagenes de un producto y el producto.Tmb veré como hacer borrados en cascada,etc
Esta sección está cargada de contenido nuevo que les puede servir mucho, especialmente si trabajan con bases de datos relacionales.

Temas que veremos:
1- Relaciones
  a. De uno a muchos
  b. Muchos a uno
2- Query Runner
3- Query Builder
4- Transacciones
5- Commits y Rollbacks
6- Renombrar tablas
7- Creación de un SEED
8- Aplanar resultados

La idea es hacer que nuestro endpoint de creación y actualización de producto permita la actualización de una tabla secundaria de la misma forma como lo hemos creado en la sección pasada.

				VIDEO 139 PRODUCT-IMAGE ENTITY

Vamos a crear una nueva tabla/entidad para las imagenes.Solo va a tener el id y un arreglo de urls:

import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class ProductImage {

  @PrimaryGeneratedColumn()
  id: string;

  @Column('text')
  url: string;
}

Recuerda que lo tengo que pasar en el module:
imports: [TypeOrmModule.forFeature([Product,ProductImage])],

Fijate que me falta la columna de product_id con la clave foránea en la tabla relacionada

				VIDEO 140 RELACIONES ONETOMANY Y MANYTOONE

Es bastante sencillo trabajar con relaciones con este framework.Fijate que lo que queremos es que se cree la columna productId en la tabla relacionada ProductImages:

En Product:                                En ProductImage:

@OneToMany(									@ManyToOne(
() => ProductImage, 					    () => Product,
(productImage) => productImage.product,     (p) => p.images
{cascade:true}                              product:Product
)
images:ProductImage[];

La sintaxis es:
@Relation(
() => Entity a relacionar,
(e) => e.field que relaciona en la otra tabla
) Desde luego no puede ser más sencillo

				VIDEO 141 CREAR IMAGENES DE UN PRODUCTO

Vamos a asegurarnos que los urls se insertan bien.Tal como está ahora,dará fallo,ya que nuestro createProductDto no tiene el campo images aún.

  @IsString({ each: true })
  @IsArray()
  @IsOptional()
  images?: string[];

En este punto vemos varios fallos aún arreglando el DTO,pues Nest no sabe que images es de tipo ProductImage[].Habrá que inyectar otro repositorio:

  constructor(
    @InjectRepository(Product)
    private readonly productRepository: Repository<Product>,
    @InjectRepository(ProductImage)
    private readonly productImageRepository: Repository<ProductImage>
  ) {}

Y ahora,cuando quiera crear una image tengo que hacerlo usando el patrón repositorio:
      const { images = [], ...productDetails } = createProductDto;

      if (!createProductDto.slug) {
        createProductDto.slug = createProductDto.title
          .toLowerCase()
          .replaceAll(' ', '_')
          .replaceAll("'", '');
      }
      const product = this.productRepository.create({
        ...productDetails,
        images: images.map((image) =>
          this.productImageRepository.create({ url: image }),
        ),
      });

				VIDEO 142 APLANAR LAS IMAGENES

Fijate que cuando busque por productos por defecto no voy a ver las imagenes,ya que es una relación.Igual que habría que hacer en mongoose con populate('ref','fields') tengo que especificarlo en cada controlador

  async findAll(pDto: PaginationDto) {
    const { limit = 10, offset = 0 } = pDto;
    return this.productRepository.find({
      take: limit,
      skip: offset,
      relations:{
        images: true
      }
    });
  }

simplemente es pasar la propiedad relations con el nombre del campo a true(esto trae todo,puedo traer solo ciertos campos)

En este punto como el true nos trae todo,realmente no queremos los ids,etc,asi que vamos a cambiar el findAll un poco:
   
   const products = await this.productRepository.find({
      take: limit,
      skip: offset,
      relations:{
        images: true
      }
    });

    return products.map(product => ({
      ...product,
      images: product.images.map( img => img.url)
    }))
  }

* Sn embargo, para el findOneBy que hemos usado tenemos un problema,ya que no permite las relaciones(a diferencia del find).
Lo que vamos a hacer es configurar la app con EagerRelations.Cualquier método find XXX traerá las relations.Hay ciertas excepciones,como al usar QueryBuilder,que no hará el populate asi sino con otro método.

Para configurar esto es tan sencillo como pasar eager a true:

  @OneToMany(
    () => ProductImage,
    (productImage) => productImage.product,
    {cascade:true,eager:true}
  )
  images?:ProductImage[];

En este punto,si hago un getOne por Id como estoy usando findOneBy({id:term}) si me va a popular,pero si busco por el slug o el title usamos el QueryBuilder y ya no lo trae.

    const queryBuilder = this.productRepository.createQueryBuilder('prod');
      product = await queryBuilder
        .where('UPPER(title) =:title or slug =:slug', {
          title: term.toUpperCase(),
          slug: term.toLowerCase(),
        })
        .leftJoinAndSelect('prod.images','prodImages')
        .getOne();

Fijate que leftJoinAndSelect(where,alias) me pide el campo y un alias.En este punto le puedo dar un alias al repositorio pasandole 'prod' en el createQueryBuilder(que ya sabe que es la entidad Producto).

 const queryBuilder = this.productRepository.createQueryBuilder('prod');
 product = await queryBuilder
   .where('UPPER(title) =:title or slug =:slug', {
      title: term.toUpperCase(),
      slug: term.toLowerCase(),
   })
   .leftJoinAndSelect('prod.images', 'prodImages')
   .getOne();
  }
    if (!product) {
      throw new NotFoundException(`Product with term ${term} not found`);
    }
    return product;
  }

  async findOnePlain(term: string) {
    // estoy llamando al findOne,para poder devolver las imagenes tmb
    const { images = [], ...rest } = await this.findOne(term);
    return {
      ...rest,
      images: images.map((i) => i.url),
    };
  }
Fijate que ahora tenemos el problema de que añadir las imagenes rompe el tipado.Una solución fácil es crear otro método,llamar al primero y añadir lo necesario y cambiar la llamada en el controlador al servicio.método adecuado.

				VIDEO 143 QUERY RUNNER

El Query Runner me va a permitir a mi ejecutar X cantidad de instrucciones SQL como si fuera una sola.Si todas salen bien las ejecutará,pero con que falle solo una puedo revertir todos los cambios.

TIP: el queryRunner es un objeto que tiene que conocer la cadena de conexión.En Nest usaremos una inyección de la clase DataSource(que ya sabe la conexión):

constructor( private readonly dataSource: DataSource){}

const queryRunner = this.dataSource.createQueryRunner(); <- esto es como una transacción,habrá que hacerla rollback o commitearla despues.

			VIDEO 144 CREANDO TRANSACCIONES

Recuerda que una transacción es una serie de queries que impactarán o no la base de datos,segun lo que yo quiera.Actuan como una sola.

NOTA: puedo ver que tengo un delete y un softDelete.Una columna marcada como softDelete realmente no se borró,solo se desactivó ??

    // create query runner
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      if (images) {
        await queryRunner.manager.delete(ProductImage, {
          // ojo que la columna se llama product en la clase ProductImage
          product: { id: id },
        });
        product.images = images.map((image) =>
          this.productImageRepository.create({ url: image }),
        );
      }
      await queryRunner.manager.save(product);
      await queryRunner.commitTransaction();
      // release libera la conexión,ojo
      await queryRunner.release();
      // await this.productRepository.save(product);
      return this.findOnePlain(id);
    } catch (error) {
      // si hubiera un error hago rollback y suelto la conexión
      await queryRunner.rollbackTransaction();
      await queryRunner.release();
      this.handleExceptions(error);
    }
  }

Fijate que es simplemente memorizar la sintaxis.

					VIDEO 145 ELIMINACIÓN EN CASCADA

De nuevo no voy a poder borrar un producto que tenga al menos una relación con imagenes.Realmente solo es ir a la entidad y especificarlo en el decorador:


@Entity()
export class ProductImage {

  @PrimaryGeneratedColumn()
  id: string;

  @Column('text')
  url: string;

  @ManyToOne(
    () => Product,
    (product) => product.images,
    { onDelete: 'CASCADE'} // si borro un producto se borran sus imagenes
  )
  product:Product;
}

Fijate que en la entidad Producto estaba asi(como cambia de cbs a un obj):
  @OneToMany(
    () => ProductImage,
    (productImage) => productImage.product,
    {cascade:true,eager:true}
  )
  images?:ProductImage[];

Ahora que tengo el delete en cascade vamos a crearnos un servicio que borre ambas tablas,lo usaremos más adelante:

  async deleteAllProducts() {
    const query = this.productRepository.createQueryBuilder('product');

    try {
      return await query.delete().where({}).execute();
    } catch (error) {
      this.handleExceptions(error);
    }
  }

De igual forma,podia haberse echo con transacciones en vez de un delete en cascada,que igual no quiero:

async remove(id: string) {
  const product = await this.findOnePlain(id);
 
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();
 
  try {
    if (product.images.length > 0) {
      await queryRunner.manager.delete(ProductImage, { product: { id } });
    }
    await queryRunner.manager.delete(Product, { id });
 
    await queryRunner.commitTransaction();
    await queryRunner.release();
 
  } catch (error) {
 
    await queryRunner.rollbackTransaction();
    await queryRunner.release();
 
    this.handleDBExceptions(error);
  }
}
Imprescindible manejar las transacciones en cualquier DB.

				VIDEO 146 PRODUCT-SEED

Queremos crear un endpoint para la carga inicial de todos los productos.Para ello crearemos un recurso:
>nest g res seed --no-spec

Fijate que la tarea de llamar al Servicio de otro modulo implica exportar el Servicio e importar el Módulo(ambas).Es decir hay que decirle al módulo que debe exportar antes de importarlo en otro.
NOTA:dado que el módulo de productos usa TypeORM es bien común exportarlo tmb al resto de la app:

En el modulo que exporta el Servicio:
@Module({
  controllers: [ProductsController],
  providers: [ProductsService],
  imports: [TypeOrmModule.forFeature([Product, ProductImage])],
  exports: [ProductsService, TypeOrmModule], <- AQUI
})
export class ProductsModule {}

Y en cualquier otro modulo que lo requiera lo debo importar:
@Module({
  controllers: [SeedController],
  providers: [SeedService],
  imports:[ProductsModule],
})
export class SeedModule {}

					VIDEO 147 INSERTAR DE FORMA MASIVA

Como siempre,lo mejor es usar un Promise.all con lo que tengo que crear las Promises.Dado que el create del productsService es async me valdrá llamarlo sin el await.

  async runSeed() {
    await this.insertNewProducts();
    return 'INITIAL SEED DATA LOADED';
  }

  private async insertNewProducts() {
    this.productsService.deleteAllProducts();

    const products = initialData.products;
    const insertPromises = [];

    products.forEach((product) => {
      insertPromises.push(this.productsService.create(product));
    });

    await Promise.all(insertPromises);

    return true;
  }

Fijate que apenas tarda 300ms.Perfecto

					VIDEO 148 RENOMBRAR TABLAS

Una de las bondades de trabajar con TypeORM es poder renombrar las tablas.Fijate que se llaman product y product_image y no tiene mucho sentido ya que son muchos productos e imagenes,no uno solo

Simplemente es pasarle el name en el decorador:
@Entity({name: 'products'})
export class Product {
